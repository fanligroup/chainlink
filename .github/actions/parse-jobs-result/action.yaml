name: Parse Jobs Result
description: Will parse GitHub action run result to json
inputs:
  github_token:
    description: "The GitHub token to use for authentication (usually github.token)"
    required: true
  github_repository:
    description: "The GitHub owner/repository to use for authentication (usually github.repository))"
    required: true
  workflow_run_id:
    description: "The workflow run ID to get the results from (usually github.run_id)"
    required: true
  github_job_name_regex:
    description: "The regex to use to match 1..many job name(s) to collect results from. Should include a capture group named 'cap' for the part of the job name you want to display in the Slack message (e.g. ^Client Compatability Test (?<cap>.*?)$)"
    required: true

outputs:
    results:
      value: ${{ steps.test-results.outputs.results }}
      description: "The parsed results in json"

runs:
  using: composite
  steps:
    - name: Get Results
      shell: bash
      id: test-results
      run: |
        # I feel like there's some clever, fully jq way to do this, but I ain't got the motivation to figure it out
        echo "Querying test results at https://api.github.com/repos/${{inputs.github_repository}}/actions/runs/${{ inputs.workflow_run_id }}/jobs"

        # we can get a maximum of 100 jobs per page, after that we need to start using pagination
        PARSED_RESULTS=$(curl \
        -H "Authorization: Bearer ${{ inputs.github_token }}" \
        'https://api.github.com/repos/${{inputs.github_repository}}/actions/runs/${{ inputs.workflow_run_id }}/jobs?per_page=100' \
        | jq -r --arg pattern "${{ inputs.github_job_name_regex }}" '.jobs[]
        | select(.name | test($pattern)) as $job
        | $job.steps[]
        | select(.name == "Run Tests")
        | { conclusion: (if .conclusion == "success" then ":white_check_mark:" else ":x:" end), cap: ("*" + ($job.name | capture($pattern).cap) + "*"), html_url: $job.html_url }')

        echo "Parsed Results:"
        echo $PARSED_RESULTS

        ALL_SUCCESS=true
        echo "Checking for failures"
        echo "$PARSED_RESULTS" | jq -s | jq -r '.[] | select(.conclusion != ":white_check_mark:")'
        for row in $(echo "$PARSED_RESULTS" | jq -s | jq -r '.[] | select(.conclusion != ":white_check_mark:")'); do
            ALL_SUCCESS=false
            break
        done
        echo "Success: $ALL_SUCCESS"

        echo all_success=$ALL_SUCCESS >> $GITHUB_OUTPUT

        FORMATTED_RESULTS=$(echo $PARSED_RESULTS | jq -s '[.[]
        | {
          conclusion: .conclusion,
          cap: .cap,
          html_url: .html_url
          }
        ]
        | map("{\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": \"<\(.html_url)|\(.cap)>: \(.conclusion)\"}}")
        | join(",")')
        
        if [ "$FORMATTED_RESULTS" = '""' ]; then
          echo skipped=true >> $GITHUB_OUTPUT
          FORMATTED_RESULTS="{\"type\": \"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": \"No test run: :ballot_box_with_check:\"}}"
        fi

        echo "Formatted Results:"
        echo $FORMATTED_RESULTS

        # Cleans out backslashes and quotes from jq
        CLEAN_RESULTS=$(echo "$FORMATTED_RESULTS" | sed 's/\\\"/"/g' | sed 's/^"//;s/"$//')

        echo "Clean Results"
        echo $CLEAN_RESULTS

        echo results=$CLEAN_RESULTS >> $GITHUB_OUTPUT
